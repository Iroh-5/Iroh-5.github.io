---
layout: post
title: "Обобщённое программирование на языке Си"
---

## Предисловие
Меня заинтересовала тема создания структур данных на языке Си, которые поддерживали бы любые типы данных. Подобные структуры доступны из коробки в таких языках, как C++, Java, C# и так далее. Но не в Си. 

Вообще, после опыта программирования на C++ я не сразу воспринял философию Си. Я привык обращаться с данными, как с объектами. Я имею в виду не экземпляры какого-то класса, а место в памяти с ассоциированным с этим местом типом. Философия, да и красота, языка Си в том, что он позволит делать тебе с памятью буквально всё что угодно, притом часто без использования явных преобразований указателей. Это, несомненно, свобода, но программист должен быть оккуратен. 

Итак, принятие этой филисофии открыло передо мной один из путей создания обобщённой структуры данных. Вы уже могли догадаться, что я говорю о так называемых указателях на ничего (ох уж этот перевод) - void\*. Существуют и другие методы. Например, с использованием макросов или также void\*, но с несколько другим подходом.

Думаю, достаточно вводной части, пора приступить к сути. В качестве примера в данной статье я покажу свою реализацию обобщённого двусвязного списка. 

## Идея
Основная идея заключается в том, что вместо данных в структуре содержится их адрес. Каждый узел нашего списка будет выглядеть так:
```c
struct lnode
{
    void* data;
    lnode* next;
    lnode* prev;
};
```
Каждый элемент списка хранит адрес объекта. Операции над структурой данных устроены так, что они принимают этот адрес, а не конкретное значение. В этом случае у пользователя будет два способа наполнять структуру объектами: 
* Он может передавать адрес объекта, размещённого на стеке
* Он может для каждого объекта создавать его копию в динамической памяти и передавать структуре его адрес

В первом случае важно, чтобы объект, лежащий на стеке "пережил" структуру данных, иначе она может попытаться освободить память, принадлежащую стеку, что невозможно. В качестве решения этой проблемы я решил предложить пользователю выбор. Как я это сделал, будеть продемонстрировано чуть позже.

## Структура списка
Сам "тип" моего двусвязного списка выглядит так:
```c
struct dll
{
    void (*destroy)(void* data);

    lnode* head;
    lnode* tail;
    size_t size;
    bool   destroy_data;
};
```
Давайте во всём по-порядку разберёмся:
```c
void (*destroy)(void* data);
```
Это указатель на "деструктор", который предоставит пользователь во время создания списка. Он нужен для освобождения занятой структурой памяти.
Пользовательский деструктор может выглядеть примерно так:
```c
void int_destroy(void* data)
{
    free((int*)data);
}
```
Далее идут по-порядку: указатель на первый элемент списка, указатель на последний элемент списка и размер спика. Это детали реализации структуры данных, которые не имеют ничего общего с обобщённостью, поэтому останавливаться на них не буду.

Последнее поле:
```c
bool destroy_data;
```
как раз отвечает за тот самый пользовательский выбор, о котором я говорил выше. Пользователь устанавливает этот параметр при создании списка. Этот параметр влияет на то, будет ли освобождена память, на которую ссылается узел списка, или нет. 

## Основные операции
### Создание списка и узла
Ниже приведена операция создания списка
```c
dll* dll_create(void (*destroy)(void* data), bool destroy_data)
{
    dll* list = malloc(sizeof(dll));
    assert(list);

    list->destroy      = destroy;
    list->head         = NULL;
    list->tail         = NULL;
    list->size         = 0;
    list->destroy_data = destroy_data;

    return list;
}
```
Ничего сложного здесь не происходит. Выделяется память под список и устанавливаются все его поля.

```c
static lnode* _node_create(void* data)
{
    lnode* node = malloc(sizeof(lnode));
    assert(node);

    node->data = data;
    node->prev = NULL;
    node->next = NULL;

    return node;
}
```
Код аналогичен предыдущему, только здесь создаётся очередной узел списка.

### Добавление в конец
Так как я не ставлю целью создать здесь исчерпывающюю структуру данных, а лишь хочу показать как можно сделать его (и не только) обобщённым, то я не стремлюсь показать здесь реализацию большого числа операций. Поэтому ниже приведу лишь реализацию операции добавления в конец списка.
```c
void dll_push_back(dll* list, void* data)
{
    lnode* new_node = _node_create(data);

    if (list->tail == NULL) // list is empty
    {
	list->head = list->tail = new_node;
    }
    else
    {
	new_node->prev   = list->tail;
	list->tail->next = new_node;
	list->tail       = new_node;
    }

    list->size++;
}
```
Большая часть кода здесь - это непосредственное добавление нового узла в конец списка. Та часть, что касается обобщённости, заключена в процедуре создания нового узла.

### Обход списка
```c
void dll_trav(dll* list, void (*op)(void* data))
{
    lnode* curr = list->head;
    while (curr != NULL)
    {
	op(curr->data);
	curr = curr->next;
    }
}
```
Это обобщённая процедура обхода списка. Она принимает в качестве параметра фукнцию для обработки объектов, задаваемую пользователем. Приведу пример такой фукнции:
```c
// Печатает целое число, хранящееся по адресу data
void int_print(void* data)
{
    printf("%d ", *((int*)data);
}
```

### Удаление списка
Удаление списка состоит из двух частей: удаление самой структуры списка и удаление каждого его узла. Удаление узла же состоит из освобождении памяти, которую он содержит(если пользователь этого пожелал), и из удаления самого узла. Ниже приведена процедура.
```c
void dll_destroy(dll* list)
{
    lnode* curr = list->head;
    while (curr != NULL)
    {
	lnode* next = curr->next;

	if (list->destroy_data)
	    list->destroy(curr->data);
	free(curr);
	
	curr = next;
    }

    free(list);
}
```

## Собираем всё вместе
Итак, на данный момент мы имеем работающий список, который принимает любые типы данных, умеет добавлять елементы в конец, печатать их, и освобождать память.
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct lnode lnode;
typedef struct dll dll;

struct dll
{
    void (*destroy)(void* data);

    lnode* head;
    lnode* tail;
    size_t size;
    bool   destroy_data;
};

struct lnode
{
    void* data;
    lnode* next;
    lnode* prev;
};

static lnode* _node_create(void* data)
{
    lnode* node = malloc(sizeof(lnode));
    assert(node);

    node->data = data;
    node->prev = NULL;
    node->next = NULL;

    return node;
}

dll* dll_create(void (*destroy)(void* data), bool destroy_data)
{
    dll* list = malloc(sizeof(dll));
    assert(list);

    list->destroy      = destroy;
    list->head         = NULL;
    list->tail         = NULL;
    list->size         = 0;
    list->destroy_data = destroy_data;

    return list;
}

void dll_push_back(dll* list, void* data)
{
    lnode* new_node = _node_create(data);

    if (list->tail == NULL) // list is empty
    {
	list->head = list->tail = new_node;
    }
    else
    {
	new_node->prev   = list->tail;
	list->tail->next = new_node;
	list->tail       = new_node;
    }

    list->size++;
}

void dll_trav(dll* list, void (*op)(void* data))
{
    lnode* curr = list->head;
    while (curr != NULL)
    {
	op(curr->data);
	curr = curr->next;
    }
}

void dll_destroy(dll* list)
{
    lnode* curr = list->head;
    while (curr != NULL)
    {
	lnode* next = curr->next;

	if (list->destroy_data)
	    list->destroy(curr->data);
	free(curr);
	
	curr = next;
    }

    free(list);
}

// Определяемые пользователем операции
void int_destroy(void* data)
{
    free((int*)data);
}

void int_print(void* data)
{
    printf("%d ", *((int*)data);
}

void int_print(void* data)
{
    printf("%f ", *((float*)data);
}

int main(void)
{
    float arr[5] = { 1.1, 2.2, 3.3, 4.4, 5.5 };
    dll* list1 = dll_create(int_destroy, false);
    for (int i = 0; i < 5; ++i)
    {
	dll_push_back(list1, arr + i);
    }
    dll_trav(list1, float_print);
    putchar('\n');

    dll* list2 = dll_create(int_destroy, true);
    for (int i = 0; i < 5; ++i)
    {
	int* tmp = malloc(sizeof(int));
	*tmp = i;
	dll_push_back(list1, tmp);
    }
    dll_trav(list2, int_print);

    return EXIT_SUCCESS;
}
```
Вывод:
```
1.1 2.2 3.3 4.4 5.5
1 2 3 4 5
```
Здесь создаётся два списка. Один хранит дробные числа, другой - целые. Первый памятью не владеет, второй владеет. Также обратите внимание на следующие строки:
```c
dll_push_back(list1, arr + i);
dll_push_back(list1, tmp);
```
В первом случае второй параметр является указателем на float, во втором случае - указателем на int. В обоих случаях язык не требует явного приведения типов. В некоторых контекстах это может только усложнить понимание кода, но в данном контексте, как я считаю, это только придало элегантности коду.

Если кто-то из вас интересуется кодом, то он содержится [здесь](https://github.com/Iroh-5/clibs). В данном репозитории вы также найдёте реализацию остальных операций списка.
## Заключение
Итак, мы получили структуру данных, которая способна содержать данные любого типа и изменять свой размер во время выполнения программы, то есть является динамической. Структуры такого рода, безусловно, полезны. Программисты, которые пишут на многих языках более "высокого" уровня, часто даже не задумываются о том, как писать код без них. В Си же такие структуры не являются необходимыми, а их построение носит больше учебный смысл. Применять их или нет - больше зависит от конкретной задачи и целей программиста. Зачастую большую часть времени программирования на Си можно обходиться вообще без динамической памяти.
